{"version":3,"sources":["controls/mainCanvas.js","controls/pieceCanvas.js","controls/btn.js","utilities.js","App.js","serviceWorker.js","index.js"],"names":["pos","isDrawing","baseCls","closeCls","dragCls","PieceCanvas","props","_this","Object","classCallCheck","this","possibleConstructorReturn","getPrototypeOf","call","_isDragging","me","assertThisInitialized","state","coordinates","currentPos","x","y","drag","bind","close","dragStart","dragEnd","container","refs","canvas","addEventListener","document","makePiece","e","stopPropagation","target","className","myId","uid","startCoo","startPos","getWidth","getHeight","style","setTimeout","onRemove","endTransitionTime","buttons","_ref","width","height","el","clientX","clientY","left","top","join","maxX","minX","maxY","minY","_ref2","positions","imgSrc","node","ctx","getContext","img","Image","src","beginPath","forEach","p","lineTo","closePath","clip","onload","drawImage","getCoordinates","react_default","a","createElement","ref","objectSpread","Component","MainCanvas","pieces","onPieceRemove","setPosition","endDrawing","draw","myCanvas","setupImage","setupListeners","id","filter","setState","restartAndReplot","then","myC","Promise","resolve","reject","setAttribute","naturalWidth","naturalHeight","recordedPos","lineWidth","lineCap","strokeStyle","stroke","coo","offsetX","offsetY","cleanupValues","_ref3","push","fromRecord","length","fillStyle","fill","popClipped","uniqueId","Date","now","piece","controls_pieceCanvas","key","concat","toConsumableArray","Btn","onClick","preventDefault","handler","cls","href","children","pageReload","window","location","reload","App","basePath","randomFile","rf","Math","floor","random","lastImg","localStorage","getItem","setItem","getRandomImage","controls_btn","controls_mainCanvas","Boolean","hostname","match","ReactDOM","render","src_App_0","getElementById","navigator","serviceWorker","ready","registration","unregister"],"mappings":"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","file":"static/js/main.ff9a80d5.chunk.js","sourcesContent":["import React, { Component } from 'react';\r\nimport PieceCanvas from './pieceCanvas';\r\nimport './mainCanvas.css';\r\n\r\n// constants (class is a singleton)\r\nlet pos; // last known position\r\nlet positions = []; // tmp positions list\r\nconst grayFillHex = '#d3d3d3';\r\nconst canvasRef = 'myCanvas';\r\nlet isDrawing;\r\nlet maxX = 0;\r\nlet maxY = 0;\r\nlet minX = 0;\r\nlet minY = 0;\r\nconst minPositionsToDraw = 10;  // less than this is probably a dot, too small to play with.\r\n\r\nclass MainCanvas extends Component {\r\n\r\n    constructor(props) {\r\n        super(props);\r\n        let me = this;\r\n        me.state = {\r\n            imgSrc: props.src,\r\n            pieces: []\r\n        }\r\n\r\n        me.onPieceRemove    = me.onPieceRemove.bind(me);\r\n        me.setPosition      = me.setPosition.bind(me);\r\n        me.endDrawing       = me.endDrawing.bind(me);\r\n        me.draw             = me.draw.bind(me);\r\n    }\r\n\r\n    //#region utils\r\n    getContext() {\r\n        const me = this;\r\n        const c = me.refs.myCanvas;\r\n        const ctx = c.getContext('2d');\r\n        return ctx;\r\n    }\r\n    //#endregion\r\n\r\n    //#region lifecycle and related\r\n    componentDidMount() {\r\n        const me = this;\r\n        me.setupImage();\r\n        me.setupListeners();\r\n    }\r\n\r\n    // filter out removed piece, trigger reflow, re-init canvas (must use js for canvas, so React render is not enough)\r\n    onPieceRemove(id) {\r\n        const me = this;\r\n        const pieces = me.state.pieces.filter(x => x.props.uid !== id);\r\n        me.setState({\r\n            pieces: pieces\r\n        }, me.restartAndReplot);\r\n    }\r\n\r\n    restartAndReplot() {\r\n        const me = this;\r\n\r\n        // fast forward whole process without removed piece.\r\n        me.setupImage()    // redraw image\r\n            .then(function () {\r\n                // now redraw shadows for pieces (pieces are simply rendered from a list in .render,\r\n                // TODO: find a way to move this to Piece control. Problem: will have to use local(parent) context(= coupling)\r\n                me.state.pieces.forEach((p) => {\r\n                    const ctx = me.getContext();\r\n                    ctx.beginPath(); // begin\r\n                    const positions = p.props.positions;\r\n                    positions.forEach((pos) => me.draw(null,  pos));\r\n                    me.endDrawing(null, true);\r\n                });\r\n            });\r\n    }\r\n    //#endregion\r\n\r\n    //#region preconditions\r\n    // setup listeners for interacting\r\n    setupListeners() {\r\n        const me = this;\r\n        const myC = me.refs.myCanvas;\r\n        myC.addEventListener('mousedown', me.setPosition);    // starts `recording`\r\n        myC.addEventListener('mousemove', me.draw);           // updates `recording feed`\r\n        myC.addEventListener('mouseup', me.endDrawing)\r\n    }\r\n\r\n    // promisified this to optimize reflows\r\n    setupImage() {\r\n        const me = this;\r\n        return new Promise(function (resolve, reject) {\r\n            const ctx = me.getContext();\r\n            const imgSrc = me.state.imgSrc;\r\n            const img = new Image();\r\n            img.src = imgSrc;\r\n            img.onload = function() {\r\n                const myC = me.refs.myCanvas;\r\n                myC.setAttribute('width', img.naturalWidth);\r\n                myC.setAttribute('height', img.naturalHeight);\r\n                ctx.drawImage(\r\n                    img,\r\n                    0,\r\n                    0\r\n                );\r\n                resolve();\r\n            }\r\n        });\r\n    }\r\n    //#endregion\r\n\r\n    //#region drawing\r\n\r\n    //  plots drawing by event or from recorded dot positions, args:\r\n    //  e - event\r\n    //  recordedPos - a position from a 'recorded' path's positions array\r\n    draw(e, recordedPos) {\r\n        if (!isDrawing && !recordedPos) {\r\n            return;\r\n        }\r\n        const me = this;\r\n        const ctx = me.getContext();\r\n\r\n        ctx.lineWidth = 1;\r\n        ctx.lineCap = 'round';\r\n        ctx.strokeStyle = '#000';\r\n\r\n        if(!recordedPos) me.setPosition(e);\r\n        let [x, y] = [pos.x, pos.y];\r\n        if(recordedPos) {\r\n            [x, y] = [recordedPos.x, recordedPos.y];\r\n        }\r\n        ctx.lineTo(x, y);\r\n\r\n        ctx.stroke();\r\n    }\r\n\r\n    setPosition(e) {\r\n        const me = this;\r\n        const coo = {x: e.offsetX, y: e.offsetY}; // coordinate on canvas\r\n\r\n        if (!isDrawing) {   // this means we start drawing now, cleanup, init min/max and begin\r\n            me.cleanupValues();\r\n            [minX, minY] = [coo.x, coo.y];\r\n            const ctx = me.getContext();\r\n            ctx.beginPath(); // begin\r\n        }\r\n        isDrawing = true;\r\n\r\n        // record min/max values for approximate 'bounds' box size.\r\n        if (coo.y > maxY) maxY = coo.y;\r\n        if (coo.x > maxX) maxX = coo.x;\r\n        if (coo.y < minY) minY = coo.y;\r\n        if (coo.x < minX) minX = coo.x;\r\n        positions.push(coo);    // record movements to keep track of drawn figure\r\n        pos = coo;\r\n    }\r\n\r\n    endDrawing(e, fromRecord) {\r\n        const me = this;\r\n        const ctx = me.getContext();\r\n\r\n        // this checks for 'dot' - just a click, not a real figure.\r\n        // reflows on true\r\n        if(e && !fromRecord) {  // 2nd condition unnecessary, left for better readability.\r\n            //console.log(positions.length); //debug\r\n            if(positions.length < minPositionsToDraw) {\r\n                me.setState({...me.state}, me.restartAndReplot);\r\n                return;\r\n            };\r\n        }\r\n\r\n        ctx.closePath();\r\n        ctx.stroke(); // draw\r\n        ctx.fillStyle = grayFillHex;\r\n        ctx.fill();\r\n\r\n        if (!fromRecord && isDrawing) me.popClipped(e);\r\n        isDrawing = false;\r\n    }\r\n\r\n    // crates a cutout `piece`\r\n    popClipped(e) {\r\n        const me = this;\r\n        const uniqueId = 'uid' + Date.now();\r\n        const piece = <PieceCanvas\r\n            positions={positions}\r\n            minX={minX}\r\n            minY={minY}\r\n            maxX={maxX}\r\n            maxY={maxY}\r\n            startPos={{x: e.clientX, y: e.clientY}}\r\n            imgSrc={me.props.src}\r\n            key={uniqueId}\r\n            uid={uniqueId}\r\n            onRemove={me.onPieceRemove}\r\n        />;\r\n\r\n        me.setState({\r\n            pieces: [...me.state.pieces, piece]\r\n        })\r\n    }\r\n\r\n    cleanupValues() {\r\n        [minX, minY, maxX, maxY, positions] = [null, null, 0, 0, []];\r\n    }\r\n    //#endregion\r\n\r\n    render() {\r\n        const me = this;\r\n        return (\r\n            <div>\r\n                <section id='canvasWrapper'>\r\n                    <canvas ref={canvasRef}></canvas>\r\n                </section>\r\n                {me.state.pieces}\r\n            </div>\r\n        )\r\n    }\r\n}\r\n\r\nexport default MainCanvas;","import React, {Component} from 'react';\r\nimport './pieceCanvas.css';\r\n\r\n// main refs\r\nconst containerRef = 'containerRef';\r\nconst canvasRef = 'canvasPiece';\r\n\r\n// constants\r\nconst baseCls = 'x-canvas-piece';\r\nconst closeCls = 'fas fa-times-circle fa-2x';\r\nconst dragCls = 'x-dragging';\r\n\r\n// value to move piece v/h to show it is cut out\r\nconst moveBy = 5;\r\n\r\nconst endTransitionTime = 0.15;\r\n\r\n//  on this class overall: i know react's reflow principle.\r\n//  But i think its not best for dragging, so\r\n//  i didnt use setstate and reflows here.\r\nclass PieceCanvas extends Component {\r\n\r\n    // because dragging listener is over whole document,\r\n    // we need inidcation for class method .drag if this\r\n    // specific instance is being dragged.\r\n    // without this, moving single piece will move all\r\n    // existing pieces\r\n    _isDragging = false;\r\n\r\n    constructor(props) {\r\n        super();\r\n        const me = this;\r\n        me.state = {\r\n            coordinates: {},\r\n            currentPos: {x: null, y: null},     // saves current position for main canvas redraws\r\n        }\r\n\r\n        me.drag         = me.drag.bind(me);\r\n        me.close        = me.close.bind(me);\r\n        me.dragStart    = me.dragStart.bind(me);\r\n        me.dragEnd      = me.dragEnd.bind(me);\r\n    }\r\n\r\n    componentDidMount() {\r\n        const me = this;\r\n        const container = me.refs[containerRef];\r\n        const canvas = me.refs[canvasRef];\r\n\r\n        // close handler\r\n        container.addEventListener('click',     me.close);\r\n\r\n        // on start/end drag listners\r\n        canvas.addEventListener('mouseup',   me.dragEnd);\r\n        canvas.addEventListener('mousedown', me.dragStart);\r\n\r\n        // this has to be whole document and not the piece,\r\n        // otherwise if we swing mouse fast, we might get out of\r\n        // the element, and the over the document(and not the\r\n        // piece) - and the dragging will be f#d up\r\n        document.addEventListener('mousemove', me.drag);\r\n\r\n        // prepare the piece\r\n        me.makePiece();\r\n    }\r\n\r\n    close(e) {\r\n        //console.log('close')\r\n        e.stopPropagation();\r\n        const me = this;\r\n        if (closeCls === e.target.className) {\r\n            e.stopPropagation();\r\n            const myId = me.props.uid;\r\n            const startCoo = {\r\n                x: me.props.startPos.x - me.getWidth() + moveBy,    // calculate start position\r\n                y: me.props.startPos.y - me.getHeight() + moveBy\r\n            };\r\n            me.refs[containerRef].style = 'transition: '+endTransitionTime+'s; left: '+startCoo.x+'px; top: '+startCoo.y+'px';\r\n            setTimeout(()=>me.props.onRemove(myId), endTransitionTime*1000);\r\n        }\r\n    }\r\n\r\n    //#region drag\r\n    drag(e) {\r\n        //console.log('drag')\r\n        e.stopPropagation();\r\n        const me = this;\r\n        if(e.buttons === 1 && me._isDragging) {\r\n            const [width, height] = [me.getWidth(), me.getHeight()];  // basic vars\r\n            const el = me.refs[containerRef];\r\n            me.state.currentPos = {x: (e.clientX-width/2)+'px', y: (e.clientY-height/2)+'px'};\r\n            el.style.left       = me.state.currentPos.x;\r\n            el.style.top        = me.state.currentPos.y;\r\n        }\r\n    }\r\n\r\n    // old comment: below methods WERE part of mechanism to prevent\r\n    // `drag overlapping` when dragging piece over piece.\r\n    // by using _isDragging flag.\r\n    // update: solved more elegantly with zIndex\r\n    dragStart(e) {\r\n        e.stopPropagation();\r\n        const me = this;\r\n        const container = me.refs[containerRef];\r\n        container.className = [baseCls,dragCls].join(' ');\r\n        me._isDragging = true;\r\n        //console.log('dragstart')\r\n    }\r\n\r\n    dragEnd(e) {\r\n        //console.log('dragend')\r\n        e.stopPropagation();\r\n        const me = this;\r\n        const container = me.refs[containerRef];\r\n        container.className = baseCls;\r\n        me._isDragging = false;\r\n    }\r\n    //#endregion\r\n\r\n    getWidth() {\r\n        const me = this;\r\n        return me.props.maxX - me.props.minX;\r\n    }\r\n\r\n    getHeight() {\r\n        const me = this;\r\n        return me.props.maxY - me.props.minY;\r\n    }\r\n\r\n    getCoordinates() {\r\n        const me = this;\r\n        // check for current position on main canvas redraws\r\n        const posX = me.state.currentPos.x || moveBy + me.props.startPos.x;\r\n        const posY = me.state.currentPos.y || moveBy + me.props.startPos.y;\r\n        return {left: posX, top: posY};\r\n    }\r\n\r\n    makePiece() {\r\n        const me = this;\r\n        let [maxX, maxY, minX, minY, positions, imgSrc] = [me.props.maxX, me.props.maxY, me.props.minX, me.props.minY, me.props.positions, me.props.imgSrc];\r\n        let node = me.refs[canvasRef];\r\n        //node.style = 'border: 1px solid red;';        //debug\r\n        node.width = maxX - minX;\r\n        node.height = maxY - minY;\r\n        const ctx = node.getContext('2d');\r\n        const img = new Image();\r\n        img.src = imgSrc;\r\n        ctx.beginPath();\r\n        positions.forEach(p => {\r\n            ctx.lineTo(p.x - minX, p.y - minY);\r\n        });\r\n        ctx.closePath();\r\n        ctx.clip();\r\n        //ctx.restore();\r\n        img.onload = function () {\r\n            ctx.drawImage(img, minX, minY, node.width, node.height, 0, 0, node.width, node.height);\r\n        }\r\n    }\r\n\r\n    render() {\r\n        const me = this;\r\n        const coordinates = me.getCoordinates();\r\n        return (\r\n            <figure ref={containerRef} style={{...coordinates}} className={baseCls}>\r\n                <canvas ref={canvasRef}></canvas>\r\n                <i className={closeCls}></i>\r\n            </figure>\r\n        );\r\n    }\r\n}\r\n\r\nexport default PieceCanvas;","import React, {Component} from 'react';\r\nimport './btn.css';\r\n\r\n// constants\r\nconst baseCls = 'x-btn';\r\n\r\nclass Btn extends Component {\r\n\r\n    constructor(props) {\r\n        super(props);\r\n        const me = this;\r\n        me.onClick = me.onClick.bind(me);\r\n    }\r\n\r\n    onClick(e) {\r\n        e.preventDefault();\r\n        const me = this;\r\n        // runs external handler if there is any\r\n        const handler = me.props.onClick;\r\n        if (handler) {\r\n            handler();\r\n        }\r\n    }\r\n\r\n    render() {\r\n        const me = this;\r\n        const cls = me.props.cls + ' ' + baseCls;\r\n        return <a onClick={me.onClick} href='/#' className={cls}>{me.props.children}</a>;\r\n    }\r\n}\r\n\r\nexport default Btn;","// utilities `library` :)\r\n\r\n// image src randomizer\r\nexport function getRandomImage() {\r\n    const [basePath, imgSuffix] = ['/images', '.jpg'];\r\n    const randomFile = () => {\r\n        const rf = Math.floor((Math.random() * 7) + 1) + imgSuffix;\r\n        return [\r\n            basePath,\r\n            rf\r\n        ].join('/');\r\n    }\r\n    let imgSrc = randomFile();\r\n    const lastImg = window.localStorage.getItem('lastImg');\r\n    while(!imgSrc || lastImg===imgSrc) {\r\n        imgSrc = randomFile();\r\n    }\r\n    window.localStorage.setItem('lastImg', imgSrc);\r\n    return imgSrc;\r\n}\r\n\r\nexport function pageReload() {\r\n    window.location.reload();\r\n}\r\n\r\nexport const randomBtnText = 'randomize image!';\r\n\r\n// Credit David Walsh (https://davidwalsh.name/javascript-debounce-function)\r\n// Returns a function, that, as long as it continues to be invoked, will not\r\n// be triggered. The function will be called after it stops being called for\r\n// N milliseconds. If `immediate` is passed, trigger the function on the\r\n// leading edge, instead of the trailing.\r\nexport function debounce(func, wait, immediate) {\r\n    var timeout;\r\n\r\n    return function executedFunction() {\r\n        var context = this;\r\n        var args = arguments;\r\n\r\n        var later = function() {\r\n            timeout = null;\r\n            if (!immediate) func.apply(context, args);\r\n        };\r\n\r\n        var callNow = immediate && !timeout;\r\n\r\n        clearTimeout(timeout);\r\n\r\n        timeout = setTimeout(later, wait);\r\n\r\n        if (callNow) func.apply(context, args);\r\n    };\r\n};\r\n","import React, { Component } from 'react';\nimport MainCanvas from './controls/mainCanvas';\nimport Btn from './controls/btn';\nimport {getRandomImage, pageReload, randomBtnText} from './utilities';\nimport './App.css';\n\nclass App extends Component {\n  render() {\n    const imgSrc = getRandomImage();\n    const randomBtnCls = 'fas fa-random';\n    return (\n      <div className=\"App\">\n        <h3 id='welcome'>Please draw a path to create a puzzle piece</h3>\n        <Btn onClick={pageReload} cls={randomBtnCls}>&nbsp;&nbsp;&nbsp;{randomBtnText}</Btn>\n        <MainCanvas src={imgSrc} />\n      </div>\n    );\n  }\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.1/8 is considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl)\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(<App />, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}