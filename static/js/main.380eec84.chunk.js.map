{"version":3,"sources":["controls/mainCanvas.js","controls/pieceCanvas.js","controls/btn.js","utilities.js","App.js","serviceWorker.js","index.js"],"names":["pos","isDrawing","baseCls","closeCls","dragCls","PieceCanvas","props","_this","Object","classCallCheck","this","possibleConstructorReturn","getPrototypeOf","call","_isDragging","me","assertThisInitialized","state","coordinates","currentPos","x","y","drag","bind","close","dragStart","dragEnd","document","addEventListener","makePiece","e","stopPropagation","target","className","myId","uid","startCoo","startPos","getWidth","getHeight","refs","style","setTimeout","onRemove","endTransitionTime","buttons","_ref","width","height","el","clientX","clientY","left","top","join","maxX","minX","maxY","minY","_ref2","positions","imgSrc","node","ctx","getContext","img","Image","src","beginPath","forEach","p","lineTo","closePath","clip","onload","drawImage","getCoordinates","react_default","a","createElement","onMouseUp","onMouseDown","ref","objectSpread","onClick","Component","MainCanvas","pieces","onPieceRemove","setPosition","endDrawing","draw","myCanvas","setupImage","id","filter","setState","restartAndReplot","then","Promise","resolve","reject","myC","setAttribute","naturalWidth","naturalHeight","recordedPos","lineWidth","lineCap","strokeStyle","stroke","coo","nativeEvent","offsetX","offsetY","cleanupValues","_ref3","push","fromRecord","length","fillStyle","fill","popClipped","uniqueId","Date","now","piece","controls_pieceCanvas","key","concat","toConsumableArray","onMouseMove","Btn","preventDefault","handler","cls","href","children","pageReload","window","location","reload","App","basePath","randomFile","rf","Math","floor","random","lastImg","localStorage","getItem","setItem","getRandomImage","controls_btn","controls_mainCanvas","Boolean","hostname","match","ReactDOM","render","src_App_0","getElementById","navigator","serviceWorker","ready","registration","unregister"],"mappings":"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","file":"static/js/main.380eec84.chunk.js","sourcesContent":["import React, { Component } from 'react';\r\nimport PieceCanvas from './pieceCanvas';\r\nimport './mainCanvas.css';\r\n\r\n// constants (class is a singleton)\r\nlet pos; // last known position\r\nlet positions = []; // tmp positions list\r\nconst grayFillHex = '#d3d3d3';\r\nconst canvasRef = 'myCanvas';\r\nlet isDrawing;\r\nlet maxX = 0;\r\nlet maxY = 0;\r\nlet minX = 0;\r\nlet minY = 0;\r\nconst minPositionsToDraw = 10;  // less than this is probably a dot, too small to play with.\r\n\r\nclass MainCanvas extends Component {\r\n\r\n    constructor(props) {\r\n        super(props);\r\n        const me = this;\r\n        me.state = {\r\n            imgSrc: props.src,\r\n            pieces: []\r\n        }\r\n\r\n        me.onPieceRemove    = me.onPieceRemove.bind(me);\r\n        me.setPosition      = me.setPosition.bind(me);\r\n        me.endDrawing       = me.endDrawing.bind(me);\r\n        me.draw             = me.draw.bind(me);\r\n    }\r\n\r\n    //#region utils\r\n    getContext() {\r\n        const me = this;\r\n        const c = me.refs.myCanvas;\r\n        const ctx = c.getContext('2d');\r\n        return ctx;\r\n    }\r\n    //#endregion\r\n\r\n    //#region lifecycle and related\r\n    componentDidMount() {\r\n        const me = this;\r\n        me.setupImage();\r\n    }\r\n\r\n    // filter out removed piece, trigger reflow, re-init canvas (must use js for canvas, so React render is not enough)\r\n    onPieceRemove(id) {\r\n        const me = this;\r\n        const pieces = me.state.pieces.filter(x => x.props.uid !== id);\r\n        me.setState({\r\n            pieces: pieces\r\n        }, me.restartAndReplot);\r\n    }\r\n\r\n    restartAndReplot() {\r\n        const me = this;\r\n\r\n        // fast forward whole process without removed piece.\r\n        me.setupImage()    // redraw image\r\n            .then(function () {\r\n                // now redraw shadows for pieces (pieces are simply rendered from a list in .render,\r\n                // TODO: find a way to move this to Piece control. Problem: will have to use local(parent) context(= coupling)\r\n                me.state.pieces.forEach((p) => {\r\n                    const ctx = me.getContext();\r\n                    ctx.beginPath(); // begin\r\n                    const positions = p.props.positions;\r\n                    positions.forEach((pos) => me.draw(null,  pos));\r\n                    me.endDrawing(null, true);\r\n                });\r\n            });\r\n    }\r\n    //#endregion\r\n\r\n    //#region\r\n    // promisified this to optimize reflows\r\n    setupImage() {\r\n        const me = this;\r\n        return new Promise(function (resolve, reject) {\r\n            const ctx = me.getContext();\r\n            const imgSrc = me.state.imgSrc;\r\n            const img = new Image();\r\n            img.src = imgSrc;\r\n            img.onload = function() {\r\n                const myC = me.refs.myCanvas;\r\n                myC.setAttribute('width', img.naturalWidth);\r\n                myC.setAttribute('height', img.naturalHeight);\r\n                ctx.drawImage(\r\n                    img,\r\n                    0,\r\n                    0\r\n                );\r\n                resolve();\r\n            }\r\n        });\r\n    }\r\n    //#endregion\r\n\r\n    //#region drawing\r\n\r\n    //  plots drawing by event or from recorded dot positions, args:\r\n    //  e - event\r\n    //  recordedPos - a position from a 'recorded' path's positions array\r\n    draw(e, recordedPos) {\r\n        if (!isDrawing && !recordedPos) {\r\n            return;\r\n        }\r\n        const me = this;\r\n        const ctx = me.getContext();\r\n\r\n        ctx.lineWidth = 1;\r\n        ctx.lineCap = 'round';\r\n        ctx.strokeStyle = '#000';\r\n\r\n        if(!recordedPos) me.setPosition(e);\r\n        let [x, y] = [pos.x, pos.y];\r\n        if(recordedPos) {\r\n            [x, y] = [recordedPos.x, recordedPos.y];\r\n        }\r\n        ctx.lineTo(x, y);\r\n\r\n        ctx.stroke();\r\n    }\r\n\r\n    setPosition(e) {\r\n        const me = this;\r\n        const coo = {x: e.nativeEvent.offsetX, y: e.nativeEvent.offsetY}; // coordinate on canvas\r\n\r\n        if (!isDrawing) {   // this means we start drawing now, cleanup, init min/max and begin\r\n            me.cleanupValues();\r\n            [minX, minY] = [coo.x, coo.y];\r\n            const ctx = me.getContext();\r\n            ctx.beginPath(); // begin\r\n        }\r\n        isDrawing = true;\r\n\r\n        // record min/max values for approximate 'bounds' box size.\r\n        if (coo.y > maxY) maxY = coo.y;\r\n        if (coo.x > maxX) maxX = coo.x;\r\n        if (coo.y < minY) minY = coo.y;\r\n        if (coo.x < minX) minX = coo.x;\r\n        positions.push(coo);    // record movements to keep track of drawn figure\r\n        pos = coo;\r\n    }\r\n\r\n    endDrawing(e, fromRecord) {\r\n        const me = this;\r\n        const ctx = me.getContext();\r\n\r\n        // this checks for 'dot' - just a click, not a real figure.\r\n        // reflows on true\r\n        if(e && !fromRecord) {  // 2nd condition unnecessary, left for better readability.\r\n            //console.log(positions.length); //debug\r\n            if(positions.length < minPositionsToDraw) {\r\n                me.setState({...me.state}, me.restartAndReplot);\r\n                return;\r\n            };\r\n        }\r\n\r\n        ctx.closePath();\r\n        ctx.stroke(); // draw\r\n        ctx.fillStyle = grayFillHex;\r\n        ctx.fill();\r\n\r\n        if (!fromRecord && isDrawing) me.popClipped(e);\r\n        isDrawing = false;\r\n    }\r\n\r\n    // crates a cutout `piece`\r\n    popClipped(e) {\r\n        const me = this;\r\n        const uniqueId = 'uid' + Date.now();\r\n        const piece = <PieceCanvas\r\n            positions={positions}\r\n            minX={minX}\r\n            minY={minY}\r\n            maxX={maxX}\r\n            maxY={maxY}\r\n            startPos={{x: e.clientX, y: e.clientY}}\r\n            imgSrc={me.props.src}\r\n            key={uniqueId}\r\n            uid={uniqueId}\r\n            onRemove={me.onPieceRemove}\r\n        />;\r\n\r\n        me.setState({\r\n            pieces: [...me.state.pieces, piece]\r\n        })\r\n    }\r\n\r\n    cleanupValues() {\r\n        [minX, minY, maxX, maxY, positions] = [null, null, 0, 0, []];\r\n    }\r\n    //#endregion\r\n\r\n    render() {\r\n        const me = this;\r\n        return (\r\n            <div>\r\n                <section id='canvasWrapper'>\r\n                    <canvas\r\n                        onMouseDown={me.setPosition}\r\n                        onMouseMove={me.draw}\r\n                        onMouseUp={me.endDrawing}\r\n                        ref={canvasRef}\r\n                    ></canvas>\r\n                </section>\r\n                {me.state.pieces}\r\n            </div>\r\n        )\r\n    }\r\n}\r\n\r\nexport default MainCanvas;","import React, {Component} from 'react';\r\nimport './pieceCanvas.css';\r\n\r\n// main refs\r\nconst containerRef = 'containerRef';\r\nconst canvasRef = 'canvasPiece';\r\n\r\n// constants\r\nconst baseCls = 'x-canvas-piece';\r\nconst closeCls = 'fas fa-times-circle fa-2x';\r\nconst dragCls = 'x-dragging';\r\n\r\n// value to move piece v/h to show it is cut out\r\nconst moveBy = 5;\r\n\r\nconst endTransitionTime = 0.15;\r\nconst ms = 1000;\r\n\r\n//  on this class overall: i know react's reflow principle.\r\n//  But i think its not best for dragging, so\r\n//  i didnt use setstate and reflows here.\r\nclass PieceCanvas extends Component {\r\n\r\n    // because dragging listener is over whole document,\r\n    // we need inidcation for class method .drag if this\r\n    // specific instance is being dragged.\r\n    // without this, moving single piece will move all\r\n    // existing pieces\r\n    _isDragging = false;\r\n\r\n    constructor(props) {\r\n        super();\r\n        const me = this;\r\n        me.state = {\r\n            coordinates: {},\r\n            currentPos: {x: null, y: null},     // saves current position for main canvas redraws\r\n        }\r\n\r\n        me.drag         = me.drag.bind(me);\r\n        me.close        = me.close.bind(me);\r\n        me.dragStart    = me.dragStart.bind(me);\r\n        me.dragEnd      = me.dragEnd.bind(me);\r\n    }\r\n\r\n    componentDidMount() {\r\n        const me = this;\r\n\r\n        // this has to be whole document and not the piece,\r\n        // otherwise if we swing mouse fast, we might get out of\r\n        // the element, and the over the document(and not the\r\n        // piece) - and the dragging will be f#d up\r\n        document.addEventListener('mousemove', me.drag);\r\n\r\n        // prepare the piece\r\n        me.makePiece();\r\n    }\r\n\r\n    close(e) {\r\n        //console.log('close')\r\n        e.stopPropagation();\r\n        const me = this;\r\n        if (closeCls === e.target.className) {\r\n            e.stopPropagation();\r\n            const myId = me.props.uid;\r\n            const startCoo = {\r\n                x: me.props.startPos.x - me.getWidth() + moveBy,    // calculate start position\r\n                y: me.props.startPos.y - me.getHeight() + moveBy\r\n            };\r\n            me.refs[containerRef].style = 'transition: '+endTransitionTime+'s; left: '+startCoo.x+'px; top: '+startCoo.y+'px';\r\n            setTimeout(()=>me && me.props.onRemove(myId), endTransitionTime*ms);\r\n        }\r\n    }\r\n\r\n    //#region drag\r\n    drag(e) {\r\n        //console.log('drag')\r\n        e.stopPropagation();\r\n        const me = this;\r\n        if(e.buttons === 1 && me._isDragging) {\r\n            const [width, height] = [me.getWidth(), me.getHeight()];  // basic vars\r\n            const el = me.refs[containerRef];\r\n            me.state.currentPos = {x: (e.clientX-width/2)+'px', y: (e.clientY-height/2)+'px'};\r\n            el.style.left       = me.state.currentPos.x;\r\n            el.style.top        = me.state.currentPos.y;\r\n        }\r\n    }\r\n\r\n    // old comment: below methods WERE part of mechanism to prevent\r\n    // `drag overlapping` when dragging piece over piece.\r\n    // by using _isDragging flag.\r\n    // update: solved more elegantly with zIndex\r\n    dragStart(e) {\r\n        e.stopPropagation();\r\n        const me = this;\r\n        const container = me.refs[containerRef];\r\n        container.className = [baseCls,dragCls].join(' ');\r\n        me._isDragging = true;\r\n        //console.log('dragstart')\r\n    }\r\n\r\n    dragEnd(e) {\r\n        //console.log('dragend')\r\n        e.stopPropagation();\r\n        const me = this;\r\n        const container = me.refs[containerRef];\r\n        container.className = baseCls;\r\n        me._isDragging = false;\r\n    }\r\n    //#endregion\r\n\r\n    getWidth() {\r\n        const me = this;\r\n        return me.props.maxX - me.props.minX;\r\n    }\r\n\r\n    getHeight() {\r\n        const me = this;\r\n        return me.props.maxY - me.props.minY;\r\n    }\r\n\r\n    getCoordinates() {\r\n        const me = this;\r\n        // check for current position on main canvas redraws\r\n        const posX = me.state.currentPos.x || moveBy + me.props.startPos.x;\r\n        const posY = me.state.currentPos.y || moveBy + me.props.startPos.y;\r\n        return {left: posX, top: posY};\r\n    }\r\n\r\n    makePiece() {\r\n        const me = this;\r\n        let [maxX, maxY, minX, minY, positions, imgSrc] = [me.props.maxX, me.props.maxY, me.props.minX, me.props.minY, me.props.positions, me.props.imgSrc];\r\n        let node = me.refs[canvasRef];\r\n        //node.style = 'border: 1px solid red;';        //debug\r\n        node.width = maxX - minX;\r\n        node.height = maxY - minY;\r\n        const ctx = node.getContext('2d');\r\n        const img = new Image();\r\n        img.src = imgSrc;\r\n        ctx.beginPath();\r\n        positions.forEach(p => {\r\n            ctx.lineTo(p.x - minX, p.y - minY);\r\n        });\r\n        ctx.closePath();\r\n        ctx.clip();\r\n        //ctx.restore();\r\n        img.onload = function () {\r\n            ctx.drawImage(img, minX, minY, node.width, node.height, 0, 0, node.width, node.height);\r\n        }\r\n    }\r\n\r\n    render() {\r\n        const me = this;\r\n        const coordinates = me.getCoordinates();\r\n        return (\r\n            <figure onMouseUp={me.dragEnd} onMouseDown={me.dragStart} ref={containerRef} style={{...coordinates}} className={baseCls}>\r\n                <canvas ref={canvasRef}></canvas>\r\n                <i onClick={me.close} className={closeCls}></i>\r\n            </figure>\r\n        );\r\n    }\r\n}\r\n\r\nexport default PieceCanvas;","import React, {Component} from 'react';\r\nimport './btn.css';\r\n\r\n// constants\r\nconst baseCls = 'x-btn';\r\n\r\nclass Btn extends Component {\r\n\r\n    constructor(props) {\r\n        super(props);\r\n        const me = this;\r\n        me.onClick = me.onClick.bind(me);\r\n    }\r\n\r\n    onClick(e) {\r\n        e.preventDefault();\r\n        const me = this;\r\n        // runs external handler if there is any\r\n        const handler = me.props.onClick;\r\n        if (handler) {\r\n            handler();\r\n        }\r\n    }\r\n\r\n    render() {\r\n        const me = this;\r\n        const cls = me.props.cls + ' ' + baseCls;\r\n        return <a onClick={me.onClick} href='/#' className={cls}>{me.props.children}</a>;\r\n    }\r\n}\r\n\r\nexport default Btn;","// utilities `library` :)\r\n\r\n// image src randomizer\r\nexport function getRandomImage() {\r\n    const [basePath, imgSuffix] = ['/images', '.jpg'];\r\n    const randomFile = () => {\r\n        const rf = Math.floor((Math.random() * 7) + 1) + imgSuffix;\r\n        return [\r\n            basePath,\r\n            rf\r\n        ].join('/');\r\n    }\r\n    let imgSrc = randomFile();\r\n    const lastImg = window.localStorage.getItem('lastImg');\r\n    while(!imgSrc || lastImg===imgSrc) {\r\n        imgSrc = randomFile();\r\n    }\r\n    window.localStorage.setItem('lastImg', imgSrc);\r\n    return imgSrc;\r\n}\r\n\r\nexport function pageReload() {\r\n    window.location.reload();\r\n}\r\n\r\nexport const randomBtnText = 'randomize image!';\r\n\r\n// Credit David Walsh (https://davidwalsh.name/javascript-debounce-function)\r\n// Returns a function, that, as long as it continues to be invoked, will not\r\n// be triggered. The function will be called after it stops being called for\r\n// N milliseconds. If `immediate` is passed, trigger the function on the\r\n// leading edge, instead of the trailing.\r\nexport function debounce(func, wait, immediate) {\r\n    var timeout;\r\n\r\n    return function executedFunction() {\r\n        var context = this;\r\n        var args = arguments;\r\n\r\n        var later = function() {\r\n            timeout = null;\r\n            if (!immediate) func.apply(context, args);\r\n        };\r\n\r\n        var callNow = immediate && !timeout;\r\n\r\n        clearTimeout(timeout);\r\n\r\n        timeout = setTimeout(later, wait);\r\n\r\n        if (callNow) func.apply(context, args);\r\n    };\r\n};\r\n","import React, { Component } from 'react';\nimport MainCanvas from './controls/mainCanvas';\nimport Btn from './controls/btn';\nimport {getRandomImage, pageReload, randomBtnText} from './utilities';\nimport './App.css';\n\nclass App extends Component {\n  render() {\n    const imgSrc = getRandomImage();\n    const randomBtnCls = 'fas fa-random';\n    return (\n      <div className=\"App\">\n        <h3 id='welcome'>Please draw a path to create a puzzle piece</h3>\n        <Btn onClick={pageReload} cls={randomBtnCls}>&nbsp;&nbsp;&nbsp;{randomBtnText}</Btn>\n        <MainCanvas src={imgSrc} />\n      </div>\n    );\n  }\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.1/8 is considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl)\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(<App />, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}