{"version":3,"sources":["controls/mainCanvas.js","controls/pieceCanvas.js","controls/btn.js","utilities.js","App.js","serviceWorker.js","index.js"],"names":["pos","isDrawing","baseCls","closeCls","dragCls","PieceCanvas","props","_this","Object","classCallCheck","this","possibleConstructorReturn","getPrototypeOf","call","_isDragging","me","assertThisInitialized","state","coordinates","currentPos","x","y","drag","bind","close","dragStart","dragEnd","container","refs","addEventListener","makePiece","e","target","className","stopPropagation","myId","uid","startCoo","startPos","getWidth","getHeight","style","setTimeout","onRemove","endTransitionTime","buttons","_ref","width","height","el","clientX","clientY","left","top","join","maxX","minX","maxY","minY","_ref2","positions","imgSrc","node","ctx","getContext","img","Image","src","beginPath","forEach","p","lineTo","closePath","clip","onload","drawImage","getCoordinates","react_default","a","createElement","ref","objectSpread","Component","MainCanvas","pieces","onPieceRemove","setPosition","endDrawing","draw","myCanvas","setupImage","setupListeners","id","filter","setState","restartAndReplot","then","myC","Promise","resolve","reject","clearRect","setAttribute","naturalWidth","naturalHeight","fromRecord","recordedPos","lineWidth","lineCap","strokeStyle","stroke","coo","offsetX","offsetY","cleanupValues","_ref3","push","length","fillStyle","fill","popClipped","uniqueId","Date","now","piece","controls_pieceCanvas","key","concat","toConsumableArray","Btn","onClick","preventDefault","handler","cls","href","children","pageReload","window","location","reload","App","basePath","randomFile","rf","Math","floor","random","lastImg","localStorage","getItem","setItem","getRandomImage","controls_btn","controls_mainCanvas","Boolean","hostname","match","ReactDOM","render","src_App_0","document","getElementById","navigator","serviceWorker","ready","registration","unregister"],"mappings":"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","file":"static/js/main.cc3f7c95.chunk.js","sourcesContent":["import React, { Component } from 'react';\r\nimport PieceCanvas from './pieceCanvas';\r\nimport './mainCanvas.css';\r\n\r\n// constants (class is a singleton)\r\nlet pos; // last known position\r\nlet positions = []; // tmp positions list\r\nconst grayFillHex = '#d3d3d3';\r\nconst canvasRef = 'myCanvas';\r\nlet isDrawing;\r\nlet maxX = 0;\r\nlet maxY = 0;\r\nlet minX = 0;\r\nlet minY = 0;\r\nconst minPositionsToDraw = 10;  // less than this is probably a dot, too small to play with.\r\n\r\nclass MainCanvas extends Component {\r\n\r\n    constructor(props) {\r\n        super(props);\r\n        let me = this;\r\n        me.state = {\r\n            imgSrc: props.src,\r\n            pieces: []\r\n        }\r\n\r\n        me.onPieceRemove    = me.onPieceRemove.bind(me);\r\n        me.setPosition      = me.setPosition.bind(me);\r\n        me.endDrawing       = me.endDrawing.bind(me);\r\n        me.draw             = me.draw.bind(me);\r\n    }\r\n\r\n    //#region utils\r\n    getContext() {\r\n        const me = this;\r\n        const c = me.refs.myCanvas;\r\n        const ctx = c.getContext('2d');\r\n        return ctx;\r\n    }\r\n    //#endregion\r\n\r\n    //#region lifecycle and related\r\n    componentDidMount() {\r\n        const me = this;\r\n        me.setupImage();\r\n        me.setupListeners();\r\n    }\r\n\r\n    // filter out removed piece, trigger reflow, re-init canvas (must use js for canvas, so React render is not enough)\r\n    onPieceRemove(id) {\r\n        const me = this;\r\n        const pieces = me.state.pieces.filter(x => x.props.uid !== id);\r\n        me.setState({\r\n            pieces: pieces\r\n        }, me.restartAndReplot);\r\n    }\r\n\r\n    restartAndReplot() {\r\n        const me = this;\r\n\r\n        // fast forward whole process without removed piece.\r\n        me.setupImage()    // redraw image\r\n            .then(function () {\r\n                // now redraw shadows for pieces (pieces are simply rendered from a list in .render,\r\n                // TODO: find a way to move this to Piece control. Problem: will have to use local(parent) context(= coupling)\r\n                me.state.pieces.forEach((p) => {\r\n                    const ctx = me.getContext();\r\n                    ctx.beginPath(); // begin\r\n                    const positions = p.props.positions;\r\n                    positions.forEach((pos) => me.draw(null, true, pos));\r\n                    me.endDrawing(null, true);\r\n                });\r\n            });\r\n    }\r\n    //#endregion\r\n\r\n    //#region preconditions\r\n    // setup listeners for interacting\r\n    setupListeners() {\r\n        const me = this;\r\n        const myC = me.refs.myCanvas;\r\n        myC.addEventListener('mousedown', me.setPosition);    // starts `recording`\r\n        myC.addEventListener('mousemove', me.draw);           // updates `recording feed`\r\n        myC.addEventListener('mouseup', me.endDrawing)\r\n    }\r\n\r\n    // promisified this to optimize reflows\r\n    setupImage() {\r\n        const me = this;\r\n        return new Promise(function (resolve, reject) {\r\n            const ctx = me.getContext();\r\n            ctx.clearRect(0, 0, me.refs.myCanvas.width, me.refs.myCanvas.height);   // redraws\r\n            const imgSrc = me.state.imgSrc;\r\n            const img = new Image();\r\n            img.src = imgSrc;\r\n            img.onload = function() {\r\n                const myC = me.refs.myCanvas;\r\n                myC.setAttribute('width', img.naturalWidth);\r\n                myC.setAttribute('height', img.naturalHeight);\r\n                ctx.drawImage(\r\n                    img,\r\n                    0,\r\n                    0\r\n                );\r\n                resolve();\r\n            }\r\n        });\r\n    }\r\n    //#endregion\r\n\r\n    //#region drawing\r\n\r\n    //  plots drawing by event or from recorded dot positions, args:\r\n    //  e - event\r\n    //  fromRecord - the user isn't drawing with mouse, we are recreating a previously 'recorded' path\r\n    //  recordedPos - a position from a 'recorded' path's positions array\r\n    draw(e, fromRecord, recordedPos) {\r\n        if (!isDrawing && !fromRecord) {\r\n            return;\r\n        }\r\n        const me = this;\r\n        const ctx = me.getContext();\r\n\r\n        ctx.lineWidth = 1;\r\n        ctx.lineCap = 'round';\r\n        ctx.strokeStyle = '#000';\r\n\r\n        if(!fromRecord) me.setPosition(e);\r\n        let [x, y] = [pos.x, pos.y];\r\n        if(recordedPos) {\r\n            [x, y] = [recordedPos.x, recordedPos.y];\r\n        }\r\n        ctx.lineTo(x, y);\r\n\r\n        ctx.stroke();\r\n    }\r\n\r\n    setPosition(e) {\r\n        const me = this;\r\n        const coo = {x: e.offsetX, y: e.offsetY}; // coordinate on canvas\r\n\r\n        if (!isDrawing) {   // this means we start drawing now, cleanup, init min/max and begin\r\n            me.cleanupValues();\r\n            [minX, minY] = [coo.x, coo.y];\r\n            const ctx = me.getContext();\r\n            ctx.beginPath(); // begin\r\n        }\r\n        isDrawing = true;\r\n\r\n        // record min/max values for approximate 'bounds' box size.\r\n        if (coo.y > maxY) maxY = coo.y;\r\n        if (coo.x > maxX) maxX = coo.x;\r\n        if (coo.y < minY) minY = coo.y;\r\n        if (coo.x < minX) minX = coo.x;\r\n        positions.push(coo);    // record movements to keep track of drawn figure\r\n        pos = coo;\r\n    }\r\n\r\n    endDrawing(e, fromRecord) {\r\n        const me = this;\r\n        const ctx = me.getContext();\r\n\r\n        // this checks for 'dot' - just a click, not a real figure.\r\n        // reflows on true\r\n        if(e && !fromRecord) {  // 2nd condition unnecessary, left for better readability.\r\n            //console.log(positions.length); //debug\r\n            if(positions.length < minPositionsToDraw) {\r\n                me.setState({...me.state}, me.restartAndReplot);\r\n                return;\r\n            };\r\n        }\r\n\r\n        ctx.closePath();\r\n        ctx.stroke(); // draw\r\n        ctx.fillStyle = grayFillHex;\r\n        ctx.fill();\r\n\r\n        if (!fromRecord && isDrawing) me.popClipped(e);\r\n        isDrawing = false;\r\n    }\r\n\r\n    // crates a cutout `piece`\r\n    popClipped(e) {\r\n        const me = this;\r\n        const uniqueId = 'uid' + Date.now();\r\n        const piece = <PieceCanvas\r\n            positions={positions}\r\n            minX={minX}\r\n            minY={minY}\r\n            maxX={maxX}\r\n            maxY={maxY}\r\n            startPos={{x: e.clientX, y: e.clientY}}\r\n            imgSrc={me.props.src}\r\n            key={uniqueId}\r\n            uid={uniqueId}\r\n            onRemove={me.onPieceRemove}\r\n        />;\r\n\r\n        me.setState({\r\n            pieces: [...me.state.pieces, piece]\r\n        })\r\n    }\r\n\r\n    cleanupValues() {\r\n        [minX, minY, maxX, maxY, positions] = [null, null, 0, 0, []];\r\n    }\r\n    //#endregion\r\n\r\n    render() {\r\n        const me = this;\r\n        return (\r\n            <div>\r\n                <section id='canvasWrapper'>\r\n                    <canvas ref={canvasRef}></canvas>\r\n                </section>\r\n                {me.state.pieces}\r\n            </div>\r\n        )\r\n    }\r\n}\r\n\r\nexport default MainCanvas;","import React, {Component} from 'react';\r\nimport './pieceCanvas.css';\r\n\r\n// main refs\r\nconst containerRef = 'containerRef';\r\nconst canvasRef = 'canvasPiece';\r\n\r\n// constants\r\nconst baseCls = 'x-canvas-piece';\r\nconst closeCls = 'fas fa-times-circle fa-2x';\r\nconst dragCls = 'x-dragging';\r\n\r\n// value to move piece v/h to show it is cut out\r\nconst moveBy = 5;\r\n\r\nconst endTransitionTime = 0.1;\r\n\r\n//  on this class overall: i know react's reflow principle.\r\n//  But i think its not best for dragging, so\r\n//  i didnt use setstate and reflows here.\r\nclass PieceCanvas extends Component {\r\n\r\n    // drag flag. dont want reflows on this one, so not a state property.\r\n    // obvious-IMPORTANT - MUST be instance property.\r\n    _isDragging = false;\r\n\r\n    constructor(props) {\r\n        super();\r\n        const me = this;\r\n        me.state = {\r\n            coordinates: {},\r\n            currentPos: {x: null, y: null},     // saves current position for main canvas redraws\r\n        }\r\n\r\n        me.drag         = me.drag.bind(me);\r\n        me.close        = me.close.bind(me);\r\n        me.dragStart    = me.dragStart.bind(me);\r\n        me.dragEnd      = me.dragEnd.bind(me);\r\n    }\r\n\r\n    componentDidMount() {\r\n        const me = this;\r\n        const container = me.refs[containerRef];\r\n        container.addEventListener('click',     me.close);\r\n        container.addEventListener('mouseup',   me.dragEnd);\r\n        container.addEventListener('mousedown', me.dragStart);\r\n        container.addEventListener('mousemove', me.drag);\r\n        me.makePiece();\r\n    }\r\n\r\n    close(e) {\r\n        //console.log('close')\r\n        const me = this;\r\n        if (closeCls === e.target.className) {\r\n            e.stopPropagation();\r\n            me._isDragging = false;\r\n            const myId = me.props.uid;\r\n            const startCoo = {\r\n                x: me.props.startPos.x - me.getWidth() + moveBy,    // calculate start position\r\n                y: me.props.startPos.y - me.getHeight() + moveBy\r\n            };\r\n            me.refs[containerRef].style = 'transition: '+endTransitionTime+'s; left: '+startCoo.x+'px; top: '+startCoo.y+'px';\r\n            setTimeout(()=>me.props.onRemove(myId), endTransitionTime*1000);\r\n        }\r\n    }\r\n\r\n    //#region drag\r\n    drag(e) {\r\n        //console.log('drag')\r\n        e.stopPropagation();\r\n        const me = this;\r\n        if(e.buttons === 1 && me._isDragging) {\r\n            const [width, height] = [me.getWidth(), me.getHeight()];  // basic vars\r\n            const el = me.refs[containerRef];\r\n            me.state.currentPos = {x: (e.clientX-width/2)+'px', y: (e.clientY-height/2)+'px'};\r\n            el.style.left       = me.state.currentPos.x;\r\n            el.style.top        = me.state.currentPos.y;\r\n        }\r\n    }\r\n\r\n    // below methods are part of mechanism to prevent\r\n    // `drag overlapping` when dragging piece over piece.\r\n    dragStart(e) {\r\n        e.stopPropagation();\r\n        const me = this;\r\n        const container = me.refs[containerRef];\r\n        container.className = [baseCls,dragCls].join(' ');\r\n        me._isDragging = true;\r\n        //console.log('dragstart')\r\n    }\r\n\r\n    dragEnd(e) {\r\n        //console.log('dragend')\r\n        e.stopPropagation();\r\n        const me = this;\r\n        const container = me.refs[containerRef];\r\n        container.className = baseCls;\r\n        me._isDragging = false;\r\n    }\r\n    //#endregion\r\n\r\n    getWidth() {\r\n        const me = this;\r\n        return me.props.maxX - me.props.minX;\r\n    }\r\n\r\n    getHeight() {\r\n        const me = this;\r\n        return me.props.maxY - me.props.minY;\r\n    }\r\n\r\n    getCoordinates() {\r\n        const me = this;\r\n        // check for current position on main canvas redraws\r\n        const posX = me.state.currentPos.x || moveBy + me.props.startPos.x;\r\n        const posY = me.state.currentPos.y || moveBy + me.props.startPos.y;\r\n        return {left: posX, top: posY};\r\n    }\r\n\r\n    makePiece() {\r\n        const me = this;\r\n        let [maxX, maxY, minX, minY, positions, imgSrc] = [me.props.maxX, me.props.maxY, me.props.minX, me.props.minY, me.props.positions, me.props.imgSrc];\r\n        let node = me.refs[canvasRef];\r\n        //node.style = 'border: 1px solid red;';        //debug\r\n        node.width = maxX - minX;\r\n        node.height = maxY - minY;\r\n        const ctx = node.getContext('2d');\r\n        const img = new Image();\r\n        img.src = imgSrc;\r\n        ctx.beginPath();\r\n        positions.forEach(p => {\r\n            ctx.lineTo(p.x - minX, p.y - minY);\r\n        });\r\n        ctx.closePath();\r\n        ctx.clip();\r\n        //ctx.restore();\r\n        img.onload = function () {\r\n            ctx.drawImage(img, minX, minY, node.width, node.height, 0, 0, node.width, node.height);\r\n        }\r\n    }\r\n\r\n    render() {\r\n        const me = this;\r\n        const coordinates = me.getCoordinates();\r\n        return (\r\n            <figure ref={containerRef} style={{...coordinates}} className={baseCls}>\r\n                <canvas ref={canvasRef}></canvas>\r\n                <i className={closeCls}></i>\r\n            </figure>\r\n        );\r\n    }\r\n}\r\n\r\nexport default PieceCanvas;","import React, {Component} from 'react';\r\nimport './btn.css';\r\n\r\n// constants\r\nconst baseCls = 'x-btn';\r\n\r\nclass Btn extends Component {\r\n\r\n    constructor(props) {\r\n        super(props);\r\n        const me = this;\r\n        me.onClick = me.onClick.bind(me);\r\n    }\r\n\r\n    onClick(e) {\r\n        e.preventDefault();\r\n        const me = this;\r\n        // runs external handler if there is any\r\n        const handler = me.props.onClick;\r\n        if (handler) {\r\n            handler();\r\n        }\r\n    }\r\n\r\n    render() {\r\n        const me = this;\r\n        const cls = me.props.cls + ' ' + baseCls;\r\n        return <a onClick={me.onClick} href='/#' className={cls}>{me.props.children}</a>;\r\n    }\r\n}\r\n\r\nexport default Btn;","// utilities `library` :)\r\n\r\n// image src randomizer\r\nexport function getRandomImage() {\r\n    const [basePath, imgSuffix] = ['/images', '.jpg'];\r\n    const randomFile = () => {\r\n        const rf = Math.floor((Math.random() * 7) + 1) + imgSuffix;\r\n        return [\r\n            basePath,\r\n            rf\r\n        ].join('/');\r\n    }\r\n    let imgSrc = randomFile();\r\n    const lastImg = window.localStorage.getItem('lastImg');\r\n    while(!imgSrc || lastImg===imgSrc) {\r\n        imgSrc = randomFile();\r\n    }\r\n    window.localStorage.setItem('lastImg', imgSrc);\r\n    return imgSrc;\r\n}\r\n\r\nexport function pageReload() {\r\n    window.location.reload();\r\n}\r\n\r\nexport const randomBtnText = 'randomize image!';\r\n\r\n// Credit David Walsh (https://davidwalsh.name/javascript-debounce-function)\r\n// Returns a function, that, as long as it continues to be invoked, will not\r\n// be triggered. The function will be called after it stops being called for\r\n// N milliseconds. If `immediate` is passed, trigger the function on the\r\n// leading edge, instead of the trailing.\r\nexport function debounce(func, wait, immediate) {\r\n    var timeout;\r\n\r\n    return function executedFunction() {\r\n        var context = this;\r\n        var args = arguments;\r\n\r\n        var later = function() {\r\n            timeout = null;\r\n            if (!immediate) func.apply(context, args);\r\n        };\r\n\r\n        var callNow = immediate && !timeout;\r\n\r\n        clearTimeout(timeout);\r\n\r\n        timeout = setTimeout(later, wait);\r\n\r\n        if (callNow) func.apply(context, args);\r\n    };\r\n};\r\n","import React, { Component } from 'react';\nimport MainCanvas from './controls/mainCanvas';\nimport Btn from './controls/btn';\nimport {getRandomImage, pageReload, randomBtnText} from './utilities';\nimport './App.css';\n\nclass App extends Component {\n  render() {\n    const imgSrc = getRandomImage();\n    const randomBtnCls = 'fas fa-random';\n    return (\n      <div className=\"App\">\n        <h3 id='welcome'>Please draw a path to create a puzzle piece</h3>\n        <Btn onClick={pageReload} cls={randomBtnCls}>&nbsp;&nbsp;&nbsp;{randomBtnText}</Btn>\n        <MainCanvas src={imgSrc} />\n      </div>\n    );\n  }\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.1/8 is considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl)\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(<App />, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}